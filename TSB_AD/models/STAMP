import numpy as np
import pandas as pd
import stumpy
import matplotlib.pyplot as plt
from sklearn.metrics import roc_auc_score
from sklearn.preprocessing import MinMaxScaler

class AnomalyDetectionConfig:
    def __init__(self, config=None):
        self.config = config or {
            "dataInput": "/content/sample_data/Yahoo_A1real_3_data.csv",
            "executionType": "execute",
            "customParameters": {
                "anomaly_window_size": 30,
                "verbose": 1,
                "n_jobs": 1,
                "random_state": 42
            }
        }
        self.input_file = self.or_op(self.config.get("dataInput"), "/content/sample_data/Yahoo_A1real_3_data.csv")
        self.window_size = self.or_op(self.config["customParameters"].get("anomaly_window_size"), 30)
        self.verbose = self.or_op(self.config["customParameters"].get("verbose"), 1)
        self.n_jobs = self.or_op(self.config["customParameters"].get("n_jobs"), 1)
        self.random_state = self.or_op(self.config["customParameters"].get("random_state"), 42)

    def or_op(self, a, b):
        return b if a is None or pd.isna(a) or (isinstance(a, float) and np.isnan(a)) or not a else a


class AnomalyDetector:
    def __init__(self, config: AnomalyDetectionConfig):
        self.config = config
        np.random.seed(config.random_state)

        if self.config.window_size < 4:
            if self.config.verbose > 0:
                print("WARN: window_size must be at least 4. Dynamically setting window_size to 4.")
            self.config.window_size = 4

    def fit(self, values):
        self.values = values
        self.anomaly_scores_ = self.compute_stamp(values)

    def compute_stamp(self, values):
        if self.config.n_jobs <= 1:
            stamp_mp = stumpy.stump(values, m=self.config.window_size)
        else:
            stamp_mp = stumpy.stump(values, m=self.config.window_size, n_threads=self.config.n_jobs)
        return stamp_mp[:, 0]

    def decision_function(self, values=None):
        if not hasattr(self, "anomaly_scores_"):
            raise ValueError("The model has not been fitted yet. Please call `fit()` first.")
        return self.anomaly_scores_

    def calculate_auc(self, labels, anomaly_scores):
        labels_adjusted = labels[self.config.window_size - 1:]
        anomaly_scores_adjusted = anomaly_scores[:len(labels_adjusted)]
        try:
            auc_roc = roc_auc_score(labels_adjusted, anomaly_scores_adjusted)
            print(f"AUC-ROC Score: {auc_roc}")
        except ValueError as e:
            print(f"Error calculating AUC-ROC: {e}")

    def plot_results(self, values, anomaly_scores_adjusted):
        fig, axs = plt.subplots(2, 1, figsize=(12, 8), sharex=True)
        axs[0].plot(values, label="Time Series", color="blue")
        axs[0].set_title("Time Series Data")
        axs[0].legend()

        axs[1].plot(range(self.config.window_size - 1, self.config.window_size - 1 + len(anomaly_scores_adjusted)),
                    anomaly_scores_adjusted, label="Anomaly Scores", color="red")
        axs[1].set_title("Anomaly Scores")
        axs[1].legend()

        plt.xlabel("Time")
        plt.tight_layout()
        plt.show()

    def run(self, data):
        values, labels = data
        self.fit(values)
        anomaly_scores_adjusted = self.decision_function()
        self.calculate_auc(labels, anomaly_scores_adjusted)
        self.plot_results(values, anomaly_scores_adjusted)

# Wrapper
def run_STAMP(data, window_size=30, n_jobs=1, random_state=42):
    values, labels = data
    config = AnomalyDetectionConfig({
        "customParameters": {
            "anomaly_window_size": window_size,
            "n_jobs": n_jobs,
            "random_state": random_state
        }
    })
    clf = AnomalyDetector(config)
    clf.fit(values)
    scores = clf.decision_function()
    scores_scaled = MinMaxScaler(feature_range=(0, 1)).fit_transform(scores.reshape(-1, 1)).ravel()
    return scores_scaled


def main():
    data_path = "/content/sample_data/Yahoo_A1real_3_data.csv"
    data = pd.read_csv(data_path)
    values = data.iloc[:, 0].values.astype(np.float64)
    labels = data.iloc[:, 1].values
    data_tuple = (values, labels)

    anomaly_scores = run_STAMP(data_tuple)

    print(anomaly_scores)


if __name__ == "__main__":
    main()
